#Jacob Kovarskiy#

import random as rnd
import math as m
from scipy.stats import norm
import numpy as np
from SVMPredictor import SVM_Predictor as SVMPredictor
from scipy import stats

class ARP_Simulator:
    def __init__(self):
        print("Starting")
        
    def countReturns(self,obj1,obj2):
        counter = 0;
        shape1=obj1.shape[1]
        for i in np.arange(shape1):
            #print(obj1[0][i].astype(int)== obj2[0][i].astype(int))
            if obj1[0][i] == obj2[0][i]:
                counter = counter + 1
        return counter
    def calc_array_obj_test(self,ambstate, trueState_1r,checkVal):
        index_range = []
        test_ambState = ambstate == checkVal
        for g in np.arange(test_ambState.shape[1]):
            if test_ambState[0][g] == True:
                index_range.append(g)
        index_ranges = []
    
        for g in np.arange(len(index_range)):
            ind = index_range[g]
            index_ranges.append(trueState_1r[0][ind])
    
        index_ranges = np.asarray(index_ranges).reshape(1,-1)
        return index_ranges
    
    def calc_array_trueState_1r(self,ambState,trueState,checkVal,numberOfSamples):
        test_amb = ambState == checkVal
        dLen = 100
        wLen = 5*dLen
        N_test = dLen*numberOfSamples//2;
        test_shape = np.zeros((dLen,N_test-wLen))
    
        trueState_list = []
        for g in np.arange(test_amb.shape[1]):
            test_shape[:,g] = trueState[:,g]
        for r in np.arange(test_shape.shape[1]):
            trueState_sum = np.sum(test_shape[:,r]).astype(int)
            if trueState_sum > 0:
                trueState_list.append(1)
            else:
                trueState_list.append(0)
        trueState_list = np.asarray(trueState_list).reshape(1,-1)
        return trueState_list
    def arpSimulatorGenerator(self,lambda1,lambda2,noOfSamples,powerLvl,isCumulants):
        pi = m.pi
        N = noOfSamples
        dLen = 100
        wLen = dLen * 5
        numberOfSamples = N
        N_train =  dLen*N//2-dLen+1;
        N_test = dLen*N//2;
        N = N_train+N_test;
        powerLvl = powerLvl #power in dBm
        lambda1 = lambda1 #arrival rate per sample
        lambda2 = lambda2 #survival rate per sample
        kParam1 = 2 #k-parameter for Erlang/gamma distribution (ON)
        kParam2 = 2 #k-parameter for Erlang/gamma distribution (OFF)
        vScale1 = 1 #scales variance relative to lambda1 (optional) 
        vScale2 = 1 #scales variance relative to lambda2 (optional)
        var1 = vScale1*lambda1 #variance parameter for log-normal distribution (ON)
        var2 = vScale2*lambda2 #variance parameter for log-normal distribution (OFF)
        occupancy = [0]*N
        stateTrans = [] #tracks alternating states [1,0,1,0,1,0,...]
        intTimes = [] #tracks intervals
        upTimes = []
        downTimes = []
        intTimesSeq = [] #counts and tracks intervals
        upDist = "lnorm"    #'exp', 'erl', or 'lnorm'
        downDist = "lnorm"  #'exp', 'erl', or 'lnorm'
        thresh_cumulants = 0.289734787404184e-03
        #process initialized to "on"
        
        totalTime = 0 #tracks total time generated by the ARP
        seqState = 1 #tracks next state to generate
        
        while totalTime < N:
            #generates on sequence
            if seqState:
                #generates random on period
                if upDist=="exp":
                    period = m.ceil(rnd.expovariate(lambda1))
                elif upDist=="erl":
                    period = m.ceil(rnd.gammavariate(kParam1,1/lambda1)) #assumes k=2
                elif upDist=="lnorm":
                    trueMu = m.log(((1/lambda1)**2)/m.sqrt((1/var1)+(1/lambda1)**2))
                    trueSig = m.sqrt(m.log((1/var1)/((1/lambda1)**2)+1))
                    period = m.ceil(rnd.lognormvariate(trueMu,trueSig)) 
                #period = 5
                
                if (totalTime+period) > N: #makes sure total time isn't exceeded
                    occupancy[totalTime:N] = [1]*(N-totalTime)
                else: #appends proper sequence of 1s
                    occupancy[totalTime:totalTime+period] = [1]*period
                    
                #tracks state transitions and on/off durations    
                stateTrans.append(1)
                intTimes.append(period)
                upTimes.append(period)
                intTimesSeq.append(list(range(1,period+1)))
                seqState = 0
                
            #generates off sequence
            else:
                #generates random off period
                if downDist=="exp":
                    period = m.ceil(rnd.expovariate(lambda2))
                elif downDist=="erl":
                    period = m.ceil(rnd.gammavariate(kParam2,1/lambda2)) #assumes k=2
                elif downDist=="lnorm":
                    #period = m.ceil(rnd.lognormvariate(lambda2,var2)) 
                    period = m.ceil(rnd.lognormvariate(np.log(((1/lambda2)**2)/np.sqrt((1/var2)+(1/lambda2)**2)),np.sqrt(np.log(1/var2)/(((1/lambda2)**2)+1))))
                #period = 10
                
                if (totalTime+period) > N: #makes sure total time isn't exceeded
                    occupancy[totalTime:N] = [0]*(N-totalTime)
                else: #appends proper sequence of 1s
                    occupancy[totalTime:totalTime+period] = [0]*period
                
                #tracks state transitions and on/off durations    
                stateTrans.append(0)
                intTimes.append(period)
                downTimes.append(period)
                intTimesSeq.append(list(range(1,period+1)))
                seqState = 1
                
            totalTime += period
            
#        seqSize = len(stateTrans) #total number of on and off states
#        traffic_intensity = sum(occupancy)/N #measures traffic intensity
#        #measures mean signal interarrival
#        mean_int = sum(intTimes[0:seqSize-(seqSize%2)]) / ((seqSize-(seqSize%2))/2) 
#        actual_int = 1/lambda1+1/lambda2 #calculates theoretical interarrival
#        
#        #reactive predictor "accuracy/error"
#        predicted = occupancy[0:N-1]
#        #theoretical accuracy based on lambda parameters
#        theoAcc = 1-(2/actual_int-1/N)
#        #accuracy based on measured mean interarrival
#        expAcc = 1-(2/mean_int-1/N)
#        #observed accuracy
#        obsAcc = sum([predicted[i]==occupancy[i+1] for i in range(N-1)]) / (N-1)
        
        
        ###input RF signal generation###
        dLen = 100 #length of the energy detector
        fs = 100e6
        time = np.linspace(0,N*dLen/fs,N*dLen)
        
        amp = m.sqrt((10**(powerLvl/10))/1000 * (2*50)) #sinusoid amplitude
        noiseVar = 1e-7 #noisefloor variance (1e-7 places noisefloor around -100 dBm)
        noisefloor = m.sqrt(noiseVar)*np.random.randn(N*dLen)
        
        sineWave = amp*np.exp(1j*2*pi*(10e6)*time) #sine wave at 10 MHz
        #SNR of the signal
        snr = 10*np.log10((sum(np.abs(sineWave)**2)/(dLen*N))/(sum(np.abs(noisefloor)**2)/(dLen*N)))
        
        #Modulates the sine wave with the occupancy state where each state has dLen samples
        occSwitch = np.repeat(occupancy,dLen)
        inputRF = sineWave*occSwitch+noisefloor
        
        P_fa = 0.01 #probability of false alarm
        #energy detector threshold
        thresh = noiseVar/m.sqrt(dLen)*(-norm.ppf(P_fa))+noiseVar
        
        #calculates total average power over a sliding window
        totalAvgPwr = np.zeros((dLen*N-dLen+1))
        pwrStates = np.zeros((dLen, dLen*N-dLen+1))
        if isCumulants:
            for i in range(dLen*N-dLen+1):
                totalAvgPwr.itemset(i,stats.kstat(np.abs(inputRF[i:i+dLen-1]),1))
                pwrStates[:,i] = np.arange(i,i+dLen)    
            obsState = totalAvgPwr > thresh_cumulants
        else:
            for i in range(dLen*N-dLen+1):
                totalAvgPwr[i] = sum(np.abs(inputRF[i:i+dLen])**2)/dLen
                pwrStates[:,i] = np.arange(i,i+dLen)
            obsState = totalAvgPwr > thresh

        dAcc = np.sum(obsState[0:dLen*N-dLen+1]==occSwitch[0:dLen*N-dLen+1])/(dLen*N-dLen+1);

        inputPwr = np.reshape(totalAvgPwr,(1,-1))
        
        svmp = SVMPredictor()
        if isCumulants:
            prediction = svmp.predictor_cumulant(numberOfSamples,inputPwr)
            threshold = 1 * thresh_cumulants            
        else:
            prediction = svmp.predictor(numberOfSamples,inputPwr)
            threshold = 1 * thresh            
        #svmp.plotSVM(inputPwr,prediction,numberOfSamples,thresh,True)
        
        score = prediction[1,:]

        numberOfSamplesLen = numberOfSamples*dLen
        predState_lstep = score > threshold
        
        predPwrStates = pwrStates[:,wLen+N_train:N]

        predPwrStates = predPwrStates.astype(int)
        occSwitch = np.reshape(occSwitch,(1,-1))
        
        
        trueState = np.zeros((dLen,numberOfSamplesLen))
        for v in np.arange(N_test-wLen):
            for c in np.arange(dLen):
                trueState.itemset((c,v),occSwitch[0,predPwrStates[c][v].astype(int)])  
        
        UA_cnt = 0;
        predAcc_UA = 0;
        
        trueState = trueState[:,0:N_test-wLen]
        
        ambState = np.zeros((N_test-wLen))
        
        for i in np.arange(N_test-wLen):
            if np.sum(trueState[:,i] == np.ones((dLen,1))) == 5:
                predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[1,i]);
                UA_cnt = UA_cnt+1
            elif np.sum(trueState[:,i] == np.zeros((dLen,1))) == 5:
                predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[1,i]);
                UA_cnt = UA_cnt+1
            else:
                ambState[i] = 1
                predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[:,i]);
                UA_cnt = UA_cnt+1;  
        predState_lstep  = np.reshape(predState_lstep,(1,-1))
        
        ambState  = np.reshape(ambState,(1,-1))
        
        trueState_1r = np.reshape(trueState[1,:],(1,-1))
        arp_simulator = ARP_Simulator()
        rSize_1 =  arp_simulator.calc_array_obj_test(ambState,predState_lstep,1)
        rSize_2 = arp_simulator.calc_array_trueState_1r(ambState,trueState,1,noOfSamples)
        
        countReturns = arp_simulator.countReturns(rSize_1,rSize_2)
        
        cal_predStep_0 = arp_simulator.calc_array_obj_test(ambState,predState_lstep,0)
        cal_trueState_1r_0 = arp_simulator.calc_array_obj_test(ambState,trueState_1r,0)
        
        cal_predStep_sum = np.sum(cal_predStep_0)
        cal_trueState_1r_sum = np.sum(cal_trueState_1r_0)

        lSize = cal_predStep_sum +cal_trueState_1r_sum
        prec_accuracy = (countReturns+lSize)/(N_test-wLen)
        return dAcc,prec_accuracy,snr
