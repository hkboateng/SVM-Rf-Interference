# -*- coding: utf-8 -*-
"""
Created on Tue Jan  7 05:05:11 2020

@author: Hubert Kyeremateng-Boateng

ARP Simulator - Cumulants
"""
#Jacob Kovarskiy#

import random as rnd
import math as m
#import matplotlib.pyplot as plt
from scipy import stats
from scipy.stats import norm
import numpy as np
from SVMPredictor import SVM_Predictor as SVMPredictor

def countReturns(self,obj1,obj2):
        counter = 0;
        shape1=obj1.shape[1]
        for i in np.arange(shape1):
            #print(obj1[0][i].astype(int)== obj2[0][i].astype(int))
            if obj1[0][i] == obj2[0][i]:
                counter = counter + 1
        return counter
    def calc_array_obj_test(self,ambstate, trueState_1r,checkVal):
        index_range = []
        test_ambState = ambstate == checkVal
        for g in np.arange(test_ambState.shape[1]):
            if test_ambState[0][g] == True:
                index_range.append(g)
        index_ranges = []
    
        for g in np.arange(len(index_range)):
            ind = index_range[g]
            index_ranges.append(trueState_1r[0][ind])
    
        index_ranges = np.asarray(index_ranges).reshape(1,-1)
        return index_ranges
    
    def calc_array_trueState_1r(self,ambState,trueState,checkVal,numberOfSamples):
        test_amb = ambState == checkVal
        dLen = 100
        wLen = 5*dLen
        N_test = dLen*numberOfSamples//2;
        test_shape = np.zeros((dLen,N_test-wLen))
    
        trueState_list = []
        for g in np.arange(test_amb.shape[1]):
            test_shape[:,g] = trueState[:,g]
        for r in np.arange(test_shape.shape[1]):
            trueState_sum = np.sum(test_shape[:,r]).astype(int)
            if trueState_sum > 0:
                trueState_list.append(1)
            else:
                trueState_list.append(0)
        trueState_list = np.asarray(trueState_list).reshape(1,-1)
        return trueState_list
pi = m.pi

powerLvl = -40 #power in dBm
lambda1 = 0.1 #arrival rate per sample
lambda2 = 0.1 #survival rate per sample
kParam1 = 2 #k-parameter for Erlang/gamma distribution (ON)
kParam2 = 2 #k-parameter for Erlang/gamma distribution (OFF)
vScale1 = 1 #scales variance relative to lambda1 (optional) 
vScale2 = 1 #scales variance relative to lambda2 (optional)
var1 = vScale1*lambda1 #variance parameter for log-normal distribution (ON)
var2 = vScale2*lambda2 #variance parameter for log-normal distribution (OFF)
N = 1000 #number of samples
numberOfSamples = N
occupancy = [0]*N
stateTrans = [] #tracks alternating states [1,0,1,0,1,0,...]
intTimes = [] #tracks intervals
upTimes = []
downTimes = []
intTimesSeq = [] #counts and tracks intervals
upDist = "lnorm"    #'exp', 'erl', or 'lnorm'
downDist = "lnorm"  #'exp', 'erl', or 'lnorm'
thresh_cumulants = 0.289734787404184e-03
#process initialized to "on"

totalTime = 0 #tracks total time generated by the ARP
seqState = 1 #tracks next state to generate

while totalTime < N:
    #generates on sequence
    if seqState:
        #generates random on period
        if upDist=="exp":
            period = m.ceil(rnd.expovariate(lambda1))
        elif upDist=="erl":
            period = m.ceil(rnd.gammavariate(kParam1,1/lambda1)) #assumes k=2
        elif upDist=="lnorm":
            trueMu = m.log(((1/lambda1)**2)/m.sqrt((1/var1)+(1/lambda1)**2))
            trueSig = m.sqrt(m.log((1/var1)/((1/lambda1)**2)+1))
            period = m.ceil(rnd.lognormvariate(trueMu,trueSig)) 
        #period = 5
        
        if (totalTime+period) > N: #makes sure total time isn't exceeded
            occupancy[totalTime:N] = [1]*(N-totalTime)
        else: #appends proper sequence of 1s
            occupancy[totalTime:totalTime+period] = [1]*period
            
        #tracks state transitions and on/off durations    
        stateTrans.append(1)
        intTimes.append(period)
        upTimes.append(period)
        intTimesSeq.append(list(range(1,period+1)))
        seqState = 0
        
    #generates off sequence
    else:
        #generates random off period
        if downDist=="exp":
            period = m.ceil(rnd.expovariate(lambda2))
        elif downDist=="erl":
            period = m.ceil(rnd.gammavariate(kParam2,1/lambda2)) #assumes k=2
        elif downDist=="lnorm":
            #period = m.ceil(rnd.lognormvariate(lambda2,var2)) 
            period = m.ceil(rnd.lognormvariate(np.log(((1/lambda2)**2)/np.sqrt((1/var2)+(1/lambda2)**2)),np.sqrt(np.log(1/var2)/(((1/lambda2)**2)+1))))
        #period = 10
        
        if (totalTime+period) > N: #makes sure total time isn't exceeded
            occupancy[totalTime:N] = [0]*(N-totalTime)
        else: #appends proper sequence of 1s
            occupancy[totalTime:totalTime+period] = [0]*period
        
        #tracks state transitions and on/off durations    
        stateTrans.append(0)
        intTimes.append(period)
        downTimes.append(period)
        intTimesSeq.append(list(range(1,period+1)))
        seqState = 1
        
    totalTime += period
    
seqSize = len(stateTrans) #total number of on and off states
traffic_intensity = sum(occupancy)/N #measures traffic intensity
#measures mean signal interarrival
mean_int = sum(intTimes[0:seqSize-(seqSize%2)]) / ((seqSize-(seqSize%2))/2) 
actual_int = 1/lambda1+1/lambda2 #calculates theoretical interarrival

#reactive predictor "accuracy/error"
predicted = occupancy[0:N-1]
#theoretical accuracy based on lambda parameters
theoAcc = 1-(2/actual_int-1/N)
#accuracy based on measured mean interarrival
expAcc = 1-(2/mean_int-1/N)
#observed accuracy
obsAcc = sum([predicted[i]==occupancy[i+1] for i in range(N-1)]) / (N-1)


###input RF signal generation###
dLen = 100 #length of the energy detector
fs = 100e6
time = np.linspace(0,N*dLen/fs,N*dLen)

amp = m.sqrt((10**(powerLvl/10))/1000 * (2*50)) #sinusoid amplitude
noiseVar = 1e-7 #noisefloor variance (1e-7 places noisefloor around -100 dBm)
noisefloor = m.sqrt(noiseVar)*np.random.randn(N*dLen)

sineWave = amp*np.exp(1j*2*pi*(10e6)*time) #sine wave at 10 MHz
#SNR of the signal
snr = 10*np.log10((sum(np.abs(sineWave)**2)/(dLen*N))/(sum(np.abs(noisefloor)**2)/(dLen*N)))

#Modulates the sine wave with the occupancy state where each state has dLen samples
occSwitch = np.repeat(occupancy,dLen)
inputRF = sineWave*occSwitch+noisefloor

P_fa = 0.01 #probability of false alarm
#energy detector threshold

#calculates total average power over a sliding window

pwrStates = np.zeros((dLen, dLen*N-dLen+1))
totalAvgPwr_cumulants = np.zeros((dLen*N-dLen+1))

for i in range(dLen*N-dLen+1):
    totalAvgPwr_cumulants.itemset(i,stats.kstat(np.abs(inputRF[i:i+dLen-1]),1))
    pwrStates[:,i] = np.arange(i,i+dLen)


#Observed states based on energy detector
obsState_cumulants = totalAvgPwr_cumulants > thresh_cumulants
#Calculates detection accuracy, false alarm rate, and missed detection rate
#detection accuracy evaluated in terms of soonest detection
dAcc_cumulants = sum(obsState_cumulants==occSwitch[range(dLen-1,dLen*N)])/(dLen*N-dLen+1)
#coherent detection accuracy with the window jumping by dLen samples
#per observations

N_train = dLen*N//2-dLen+1; #training data length
#Training label ground truth/target
wLen = 5*dLen; 
N_test = dLen*N//2; #test data length 
N = N_train+N_test; #total data length

prediction = None
inputPwr_cumulants = np.reshape(totalAvgPwr_cumulants,(1,-1))

svmp = SVMPredictor()
prediction = svmp.predictor_cumulant(numberOfSamples,inputPwr_cumulants)
svmp.plotSVM(inputPwr_cumulants,prediction,numberOfSamples,thresh_cumulants,True)
score = prediction[1,:]
threshold = 1 * thresh_cumulants
numberOfSamplesLen = numberOfSamples*dLen
predState_lstep = score > threshold
#predState_lstep_sum = np.sum(score > threshold)
predPwrStates = pwrStates[:,wLen+1+N_train:N]

predPwrStates = predPwrStates.astype(int)
occSwitch = np.reshape(occSwitch,(1,-1))


trueState = np.zeros((dLen,numberOfSamplesLen))
for v in np.arange(predPwrStates.shape[1]):
    for c in np.arange(dLen):
        trueState.itemset((c,v),occSwitch[0,v+c+1])  

UA_cnt = 0;
predAcc_UA = 0;

trueState_v2 = trueState[:,0:N_test-wLen]

ambState = np.zeros((N_test-wLen))

val_col = []
val_row = []
for i in np.arange(N_test-wLen):
    valZero = 0
    valOnes = 0
    rDLen = trueState_v2[:,i]
    for r in np.arange(dLen-1):
        if rDLen[r] == 1:
            valOnes = valOnes + 1
        if rDLen[r] == 0:
            valZero = valZero + 1

    if valOnes == 5:
        predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[1,i]);
        UA_cnt = UA_cnt+1
    elif valZero == 5:
        predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[1,i]);
        UA_cnt = UA_cnt+1
    else:
        ambState[i] = 1
        predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[:,i]);
        UA_cnt = UA_cnt+1;
#    if np.sum(trueState_v2[:,i] == np.ones((1,dLen))) == 5:
#        predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[1,i]);
#        UA_cnt = UA_cnt+1
#    elif np.sum(trueState_v2[:,i] == np.zeros((1,dLen))) == 5:
#        predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[1,i]);
#        UA_cnt = UA_cnt+1
#    else:
#        ambState[i] = 1
#        predAcc_UA = predAcc_UA + (predState_lstep[i] == trueState[:,i]);
#        UA_cnt = UA_cnt+1;       
predState_lstep  = np.reshape(predState_lstep,(1,-1))

ambState  = np.reshape(ambState,(1,-1))

trueState_1r = np.reshape(trueState_v2[1,:],(1,-1))
#predState_lstep = predState_lstep.astype(int)


rSize_1 =  calc_array_obj_test(ambState,predState_lstep,1)
rSize_2 =  calc_array_trueState_1r(ambState,trueState_v2,1)

rSize_1_sum = np.sum(rSize_1)
rSize_2_sum = np.sum(rSize_2)

countReturns = countReturns(rSize_1,rSize_2)
lSize = np.sum(calc_array_obj_test(ambState,predState_lstep,0)== calc_array_obj_test(ambState,trueState_1r,0))
print((countReturns+lSize)/(N_test-wLen))
#print((np.sum(calc_array_obj_test(ambState,predState_lstep,0)== calc_array_obj_test(ambState,trueState_1r,0))+np.sum(calc_array_obj_test(ambState,predState_lstep,1) == calc_array_trueState_1r(ambState,trueState_1r,1))))
#print((np.sum(calc_array_obj_test(ambState,predState_lstep,0)== calc_array_obj_test(ambState,trueState_1r,0))+np.sum(calc_array_obj_test(ambState,predState_lstep,1) == calc_array_trueState_1r(ambState,trueState_1r,1)))/(N_test-wLen))


